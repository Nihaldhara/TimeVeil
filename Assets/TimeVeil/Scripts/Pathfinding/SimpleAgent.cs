using System.Collections;
using System.Collections.Generic;
using UnityEngine;

/// <summary>
/// Use for the agent state
/// </summary>
public enum AgentState { OFF, MOVE, DONE }

[RequireComponent(typeof(Pathfinding))]
/// <summary>
/// Controls unit movement along a path generated by the Pathfinding component.
/// </summary>
public class SimpleAgent : MonoBehaviour
{
    [Header("Configuration")]
    /// <summary>
    /// Movement speed of the unit.
    /// </summary>
    [SerializeField] private float m_Speed = 5f;
    /// <summary>
    /// Reference to the Pathfinding component used to retrieve paths.
    /// </summary>
    private Pathfinding m_Pathfinding;
    /// <summary>
    /// Index of the current target waypoint in the path.
    /// </summary>
    int m_TargetIndex;
    /// <summary>
    /// Array of waypoints representing the current path.
    /// </summary>
    private Vector3[] m_Path;

    public Vector3[] Path
    {
        get => m_Path;
        set => m_Path = value;
    }

    /// <summary>
    /// Reference to the coroutine handling path following.
    /// </summary>
    private Coroutine m_FollowPathCoroutine;

    /// <summary>
    /// Current Agent State
    /// </summary>
    private AgentState m_AgentState;

    /// <summary>
    /// Public enum for AgentState
    /// </summary>
    public AgentState AgentState
    {
        get { return m_AgentState; }
    }

    /// <summary>
    /// Initializes the Pathfinding reference and subscribes to path update events.
    /// </summary>
    void Awake()
    {
        m_Pathfinding = GetComponent<Pathfinding>();
        m_Pathfinding.OnPathUpdatedEvent += OnPathChanged;
    }


    /// <summary>
    /// Coroutine that moves the unit along the current path.
    /// </summary>
    IEnumerator FollowPath()
    {

        if (m_Path == null || m_Path.Length == 0)
        {
            Debug.Log("[My Debug] Path is empty");
            yield break;
        }

        Vector3 currentWaypoint = GetClosestWaypoint();

        while (true)
        {
            if (Vector3.Distance(transform.position, currentWaypoint) < 0.1f)
            {
                m_TargetIndex++;
                if (m_TargetIndex >= m_Path.Length)
                {
                    Debug.Log($"[My Debug] State : {m_AgentState}");
                    m_AgentState = AgentState.DONE;
                    yield break;
                }
                currentWaypoint = m_Path[m_TargetIndex];
            }

            transform.position = Vector3.MoveTowards(transform.position, currentWaypoint, m_Speed * Time.deltaTime);
            RotateTowards(currentWaypoint);
            //Debug.Log($"[My Debug] State : {m_AgentState}");
            m_AgentState = AgentState.MOVE;
            yield return null;
        }

    }

    /// <summary>
    /// Callback invoked when the path is updated. Restarts movement if the path has changed.
    /// </summary>
    void OnPathChanged(List<Node> newPath)
    {
        Vector3[] newWorldPath = newPath.ConvertAll(n => n.WorldPosition).ToArray();

        if (m_Path != null && AreWorldPathsEqual(m_Path, newWorldPath)) return;

        m_Path = newWorldPath;
        m_TargetIndex = 0;

        if (m_FollowPathCoroutine != null)
        {
            StopCoroutine(m_FollowPathCoroutine);
        }

        m_FollowPathCoroutine = StartCoroutine(FollowPath());
    }

    /// <summary>
    /// Compares two paths to determine if they are effectively the same.
    /// </summary>
    bool AreWorldPathsEqual(Vector3[] a, Vector3[] b)
    {
        if (a.Length != b.Length) return false;
        for (int i = 0; i < a.Length; i++)
        {
            if (Vector3.Distance(a[i], b[i]) > 0.1f) return false;
        }
        return true;
    }

    /// <summary>
    /// Rotates the unit to face the direction of movement.
    /// </summary>
    private void RotateTowards(Vector3 targetPosition)
    {
        Vector3 direction = (targetPosition - transform.position).normalized;
        if (direction != Vector3.zero)
        {
            Quaternion lookRotation = Quaternion.LookRotation(direction);
            transform.rotation = Quaternion.Slerp(transform.rotation, lookRotation, Time.deltaTime * 10f);
        }
    }

    /// <summary>
    /// Finds the closest waypoint in the path to the unit's current position.
    /// </summary>
    private Vector3 GetClosestWaypoint()
    {
        float minDist = float.MaxValue;
        int closestIndex = 0;
        for (int i = 0; i < m_Path.Length; i++)
        {
            float dist = Vector3.Distance(transform.position, m_Path[i]);
            if (dist < minDist)
            {
                minDist = dist;
                closestIndex = i;
            }
        }
        m_TargetIndex = closestIndex;
        return m_Path[m_TargetIndex];
    }


}
